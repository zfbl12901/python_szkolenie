---
title: "REST"
order: 8.02.01
parent: "08-02-apis-services.md"
tags: ["python", "rest", "api", "http"]
---

# REST

REST (Representational State Transfer) est un style architectural pour concevoir des APIs web. Il définit des conventions pour créer des APIs simples, scalables et maintenables.

## Concepts de base

**REST** n'est pas un protocole mais un **style architectural** qui utilise HTTP comme protocole de transport. Il définit des principes pour structurer les interactions entre client et serveur.

### Principes fondamentaux

- **Stateless** : Chaque requête contient toute l'information nécessaire
- **Ressources** : Tout est une ressource identifiée par une URL
- **Représentations** : Les ressources sont représentées (JSON, XML, etc.)
- **Actions HTTP** : Utilise les méthodes HTTP standard (GET, POST, PUT, DELETE)

## Principes REST

### 1. Ressources et URIs

Les ressources sont identifiées par des URIs (Uniform Resource Identifiers) :

```python
# ✅ Bon : URIs représentent des ressources
GET    /users              # Liste des utilisateurs
GET    /users/123          # Utilisateur spécifique
GET    /users/123/posts    # Posts d'un utilisateur
POST   /users              # Créer un utilisateur
PUT    /users/123          # Mettre à jour un utilisateur
DELETE /users/123          # Supprimer un utilisateur

# ❌ Éviter : URIs avec actions
GET    /getUser?id=123
POST   /createUser
POST   /updateUser
POST   /deleteUser
```

### 2. Méthodes HTTP

Chaque méthode HTTP a une sémantique précise :

- **GET** : Récupérer une ressource (idempotent, sans effet de bord)
- **POST** : Créer une nouvelle ressource
- **PUT** : Remplacer complètement une ressource (idempotent)
- **PATCH** : Modifier partiellement une ressource
- **DELETE** : Supprimer une ressource (idempotent)

### 3. Stateless

Chaque requête doit contenir toute l'information nécessaire :

```python
# ✅ Bon : Stateless
GET /users/123
Headers: Authorization: Bearer <token>

# ❌ Éviter : Stateful (session serveur)
GET /users/123
Cookie: session_id=abc123  # Serveur doit maintenir l'état
```

### 4. Représentations

Les ressources peuvent être représentées dans différents formats :

```python
# JSON (le plus courant)
GET /users/123
Accept: application/json
Response: {"id": 123, "name": "Alice"}

# XML
GET /users/123
Accept: application/xml
Response: <user><id>123</id><name>Alice</name></user>
```

## Méthodes HTTP

### GET - Récupérer

```python
# Flask
@app.get('/users/<int:user_id>')
def get_user(user_id):
    user = find_user(user_id)
    if not user:
        return {'error': 'Not found'}, 404
    return jsonify(user)

# FastAPI
@app.get("/users/{user_id}")
def get_user(user_id: int):
    user = find_user(user_id)
    if not user:
        raise HTTPException(status_code=404, detail="User not found")
    return user
```

**Caractéristiques** :
- Idempotent (plusieurs appels = même résultat)
- Sans effet de bord
- Peut être mis en cache
- Ne doit pas modifier l'état du serveur

### POST - Créer

```python
# Flask
@app.post('/users')
def create_user():
    data = request.get_json()
    user = create_user(data)
    return jsonify(user), 201

# FastAPI
@app.post("/users", status_code=201)
def create_user(user: UserCreate):
    new_user = create_user(user.dict())
    return new_user
```

**Caractéristiques** :
- Crée une nouvelle ressource
- Non idempotent (chaque appel crée une nouvelle ressource)
- Retourne généralement 201 (Created)
- Location header avec l'URI de la ressource créée

### PUT - Remplacer

```python
@app.put('/users/<int:user_id>')
def update_user(user_id):
    data = request.get_json()
    user = replace_user(user_id, data)
    if not user:
        return {'error': 'Not found'}, 404
    return jsonify(user)
```

**Caractéristiques** :
- Remplace complètement la ressource
- Idempotent (plusieurs appels = même résultat)
- Si la ressource n'existe pas, peut la créer (upsert)

### PATCH - Modifier partiellement

```python
@app.patch('/users/<int:user_id>')
def partial_update_user(user_id):
    data = request.get_json()
    user = partial_update_user(user_id, data)
    if not user:
        return {'error': 'Not found'}, 404
    return jsonify(user)
```

**Caractéristiques** :
- Modifie partiellement une ressource
- Non idempotent (dépend des modifications)
- Plus flexible que PUT

### DELETE - Supprimer

```python
@app.delete('/users/<int:user_id>')
def delete_user(user_id):
    if delete_user(user_id):
        return '', 204  # No Content
    return {'error': 'Not found'}, 404
```

**Caractéristiques** :
- Supprime une ressource
- Idempotent (supprimer plusieurs fois = même résultat)
- Retourne généralement 204 (No Content) ou 200

## Statuts HTTP

### Codes de succès

```python
200 OK              # Requête réussie (GET, PUT, PATCH)
201 Created         # Ressource créée (POST)
204 No Content      # Succès sans contenu (DELETE)
```

### Codes d'erreur client

```python
400 Bad Request     # Requête mal formée
401 Unauthorized    # Authentification requise
403 Forbidden       # Accès refusé
404 Not Found       # Ressource introuvable
409 Conflict        # Conflit (ex: email déjà utilisé)
422 Unprocessable Entity  # Validation échouée
```

### Codes d'erreur serveur

```python
500 Internal Server Error  # Erreur serveur
502 Bad Gateway            # Problème avec un service externe
503 Service Unavailable    # Service temporairement indisponible
```

### Exemples d'utilisation

```python
from flask import Flask, jsonify, request

app = Flask(__name__)

@app.get('/users/<int:user_id>')
def get_user(user_id):
    user = find_user(user_id)
    if not user:
        return jsonify({'error': 'User not found'}), 404
    return jsonify(user), 200

@app.post('/users')
def create_user():
    data = request.get_json()
    if not data or 'email' not in data:
        return jsonify({'error': 'Invalid data'}), 400
    
    if user_exists(data['email']):
        return jsonify({'error': 'Email already exists'}), 409
    
    user = create_user(data)
    return jsonify(user), 201

@app.delete('/users/<int:user_id>')
def delete_user(user_id):
    if not user_exists(user_id):
        return jsonify({'error': 'User not found'}), 404
    
    delete_user(user_id)
    return '', 204
```

## Bonnes pratiques

### 1. Utilisez des noms de ressources au pluriel

```python
# ✅ Bon
GET /users
GET /users/123
GET /posts
GET /posts/456

# ❌ Éviter
GET /user
GET /user/123
```

### 2. Utilisez des noms de ressources en minuscules

```python
# ✅ Bon
GET /api/users
GET /api/user-posts

# ❌ Éviter
GET /api/Users
GET /api/UserPosts
```

### 3. Utilisez des verbes HTTP, pas dans l'URI

```python
# ✅ Bon
POST /users          # Créer
PUT  /users/123      # Mettre à jour
DELETE /users/123    # Supprimer

# ❌ Éviter
POST /users/create
POST /users/123/update
POST /users/123/delete
```

### 4. Versionnez votre API

```python
# ✅ Bon
GET /api/v1/users
GET /api/v2/users

# Ou avec un header
GET /api/users
Headers: API-Version: v1
```

### 5. Utilisez la pagination

```python
# ✅ Bon
GET /users?page=1&limit=10
Response: {
    "data": [...],
    "pagination": {
        "page": 1,
        "limit": 10,
        "total": 100,
        "pages": 10
    }
}
```

### 6. Filtrage, tri et recherche

```python
# ✅ Bon
GET /users?status=active&role=admin
GET /users?sort=name&order=asc
GET /users?search=alice
```

### 7. Réponses cohérentes

```python
# ✅ Bon : Format cohérent
{
    "data": {...},
    "meta": {...},
    "errors": [...]
}

# Ou pour les listes
{
    "items": [...],
    "total": 100,
    "page": 1
}
```

## Exemples pratiques

### Exemple 1 : API REST complète avec Flask

```python
from flask import Flask, jsonify, request
from flask.views import MethodView

app = Flask(__name__)

users = []
next_id = 1

class UserAPI(MethodView):
    def get(self, user_id=None):
        if user_id:
            user = next((u for u in users if u['id'] == user_id), None)
            if not user:
                return jsonify({'error': 'Not found'}), 404
            return jsonify(user)
        
        # Liste avec pagination
        page = int(request.args.get('page', 1))
        limit = int(request.args.get('limit', 10))
        start = (page - 1) * limit
        end = start + limit
        
        return jsonify({
            'items': users[start:end],
            'total': len(users),
            'page': page,
            'limit': limit
        })
    
    def post(self):
        data = request.get_json()
        if not data or 'name' not in data:
            return jsonify({'error': 'Invalid data'}), 400
        
        global next_id
        user = {
            'id': next_id,
            'name': data['name'],
            'email': data.get('email')
        }
        next_id += 1
        users.append(user)
        
        return jsonify(user), 201
    
    def put(self, user_id):
        user = next((u for u in users if u['id'] == user_id), None)
        if not user:
            return jsonify({'error': 'Not found'}), 404
        
        data = request.get_json()
        user.update(data)
        return jsonify(user)
    
    def delete(self, user_id):
        global users
        user = next((u for u in users if u['id'] == user_id), None)
        if not user:
            return jsonify({'error': 'Not found'}), 404
        
        users = [u for u in users if u['id'] != user_id]
        return '', 204

# Enregistrer les routes
user_view = UserAPI.as_view('user_api')
app.add_url_rule('/users', view_func=user_view, methods=['GET', 'POST'])
app.add_url_rule('/users/<int:user_id>', view_func=user_view, methods=['GET', 'PUT', 'DELETE'])
```

### Exemple 2 : API REST avec FastAPI

```python
from fastapi import FastAPI, HTTPException, Query
from pydantic import BaseModel
from typing import List, Optional

app = FastAPI()

class UserCreate(BaseModel):
    name: str
    email: str

class UserResponse(BaseModel):
    id: int
    name: str
    email: str

users_db = []
next_id = 1

@app.get("/users", response_model=List[UserResponse])
def list_users(
    page: int = Query(1, ge=1),
    limit: int = Query(10, ge=1, le=100)
):
    start = (page - 1) * limit
    end = start + limit
    return users_db[start:end]

@app.get("/users/{user_id}", response_model=UserResponse)
def get_user(user_id: int):
    user = next((u for u in users_db if u['id'] == user_id), None)
    if not user:
        raise HTTPException(status_code=404, detail="User not found")
    return user

@app.post("/users", response_model=UserResponse, status_code=201)
def create_user(user: UserCreate):
    global next_id
    new_user = {
        'id': next_id,
        **user.dict()
    }
    next_id += 1
    users_db.append(new_user)
    return new_user

@app.put("/users/{user_id}", response_model=UserResponse)
def update_user(user_id: int, user: UserCreate):
    existing = next((u for u in users_db if u['id'] == user_id), None)
    if not existing:
        raise HTTPException(status_code=404, detail="User not found")
    
    existing.update(user.dict())
    return existing

@app.delete("/users/{user_id}", status_code=204)
def delete_user(user_id: int):
    global users_db
    user = next((u for u in users_db if u['id'] == user_id), None)
    if not user:
        raise HTTPException(status_code=404, detail="User not found")
    users_db = [u for u in users_db if u['id'] != user_id]
    return None
```

## Points clés à retenir

- ✅ REST est un **style architectural**, pas un protocole
- ✅ Utilise les **méthodes HTTP** avec leur sémantique
- ✅ **Stateless** : chaque requête est indépendante
- ✅ **Ressources** identifiées par des URIs
- ✅ **Codes de statut HTTP** appropriés
- ✅ **Format cohérent** pour les réponses
- ✅ **Versioning** de l'API
- ✅ **Pagination** pour les listes

REST est le style le plus utilisé pour concevoir des APIs web. Suivre ces principes garantit des APIs simples, maintenables et faciles à utiliser.
