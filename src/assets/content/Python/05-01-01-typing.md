---
title: "typing"
order: 5.01.01
parent: "05-01-typage-statique-optionnel.md"
tags: ["python", "typing", "module", "annotations"]
---

# typing

Le module `typing` fournit les outils nécessaires pour ajouter des annotations de type à votre code Python. Introduit dans Python 3.5 et amélioré depuis, c'est le module standard pour le typage statique optionnel.

## Concepts de base

Le module `typing` permet de :
- **Documenter** les types attendus dans votre code
- **Améliorer l'autocomplétion** dans les IDE
- **Détecter des erreurs** avec des outils comme mypy ou pyright
- **Améliorer la maintenabilité** du code

Les annotations de type sont **optionnelles** et **non vérifiées à l'exécution** par défaut. Elles servent principalement à l'analyse statique.

## Types de base

### Types primitifs

Les types de base Python peuvent être utilisés directement :

```python
def additionner(a: int, b: int) -> int:
    """Additionne deux entiers."""
    return a + b

def concatener(a: str, b: str) -> str:
    """Concatène deux chaînes."""
    return a + b

def est_positif(n: float) -> bool:
    """Vérifie si un nombre est positif."""
    return n > 0
```

### Types de collections (Python 3.9+)

Depuis Python 3.9, vous pouvez utiliser les types natifs directement :

```python
# Python 3.9+
def traiter_nombres(nombres: list[int]) -> list[int]:
    """Traite une liste d'entiers."""
    return [x * 2 for x in nombres]

def obtenir_ages(utilisateurs: dict[str, int]) -> list[int]:
    """Extrait les âges d'un dictionnaire."""
    return list(utilisateurs.values())
```

### Types de collections (Python < 3.9)

Pour les versions antérieures, utilisez le module `typing` :

```python
from typing import List, Dict, Tuple, Set

def traiter_nombres(nombres: List[int]) -> List[int]:
    """Traite une liste d'entiers."""
    return [x * 2 for x in nombres]

def obtenir_ages(utilisateurs: Dict[str, int]) -> List[int]:
    """Extrait les âges d'un dictionnaire."""
    return list(utilisateurs.values())
```

## Collections typées

### List

```python
from typing import List

def trier_nombres(nombres: List[int]) -> List[int]:
    """Trie une liste d'entiers."""
    return sorted(nombres)

def filtrer_pairs(nombres: List[int]) -> List[int]:
    """Filtre les nombres pairs."""
    return [n for n in nombres if n % 2 == 0]
```

### Dict

```python
from typing import Dict

def compter_mots(texte: str) -> Dict[str, int]:
    """Compte les occurrences de chaque mot."""
    mots = texte.split()
    return {mot: mots.count(mot) for mot in set(mots)}

def mettre_a_jour_utilisateur(
    utilisateur: Dict[str, str],
    modifications: Dict[str, str]
) -> Dict[str, str]:
    """Met à jour un utilisateur."""
    utilisateur.update(modifications)
    return utilisateur
```

### Tuple

```python
from typing import Tuple

def obtenir_coordonnees() -> Tuple[float, float]:
    """Retourne des coordonnées (x, y)."""
    return (10.5, 20.3)

def diviser(numerateur: int, denominateur: int) -> Tuple[bool, float]:
    """Divise deux nombres. Retourne (succès, résultat)."""
    if denominateur == 0:
        return (False, 0.0)
    return (True, numerateur / denominateur)
```

### Set

```python
from typing import Set

def obtenir_nombres_uniques(nombres: List[int]) -> Set[int]:
    """Retourne un ensemble de nombres uniques."""
    return set(nombres)

def intersection(ensemble1: Set[str], ensemble2: Set[str]) -> Set[str]:
    """Calcule l'intersection de deux ensembles."""
    return ensemble1 & ensemble2
```

## Callable et fonctions

### Callable

`Callable` permet de typer les fonctions et callables :

```python
from typing import Callable

def appliquer(
    fonction: Callable[[int, int], int],
    a: int,
    b: int
) -> int:
    """Applique une fonction à deux arguments."""
    return fonction(a, b)

# Utilisation
def additionner(x: int, y: int) -> int:
    return x + y

resultat = appliquer(additionner, 5, 3)  # 8
```

### Signature de fonction

```python
from typing import Callable

# Fonction sans arguments
def executer(fonction: Callable[[], str]) -> str:
    return fonction()

# Fonction avec arguments variables
def executer_variable(fonction: Callable[..., int]) -> int:
    return fonction(1, 2, 3)

# Fonction avec arguments nommés
def executer_nomme(
    fonction: Callable[[int, int], int],
    a: int,
    b: int
) -> int:
    return fonction(a, b)
```

## Types génériques

### TypeVar

`TypeVar` permet de créer des types génériques :

```python
from typing import TypeVar, List

T = TypeVar('T')

def premier_element(liste: List[T]) -> T:
    """Retourne le premier élément d'une liste."""
    return liste[0]

# Utilisation avec différents types
nombres: List[int] = [1, 2, 3]
premier_nombre: int = premier_element(nombres)

mots: List[str] = ["a", "b", "c"]
premier_mot: str = premier_element(mots)
```

### Generic

Pour créer des classes génériques :

```python
from typing import TypeVar, Generic

T = TypeVar('T')

class Pile(Generic[T]):
    """Pile générique."""
    def __init__(self):
        self._elements: List[T] = []
    
    def empiler(self, element: T) -> None:
        """Empile un élément."""
        self._elements.append(element)
    
    def depiler(self) -> T:
        """Dépile un élément."""
        return self._elements.pop()

# Utilisation
pile_entiers = Pile[int]()
pile_entiers.empiler(1)
pile_entiers.empiler(2)
nombre: int = pile_entiers.depiler()

pile_chaines = Pile[str]()
pile_chaines.empiler("hello")
mot: str = pile_chaines.depiler()
```

## Types spéciaux

### Any

`Any` représente n'importe quel type (à utiliser avec parcimonie) :

```python
from typing import Any

def accepter_tout(valeur: Any) -> Any:
    """Accepte et retourne n'importe quel type."""
    return valeur

# ⚠️ Any désactive le type checking
```

### None

`None` est un type à part entière :

```python
def peut_retourner_none(x: int) -> int | None:
    """Peut retourner None."""
    if x < 0:
        return None
    return x

# Ou avec Optional (voir section suivante)
from typing import Optional

def peut_retourner_none_optional(x: int) -> Optional[int]:
    """Peut retourner None (équivalent)."""
    if x < 0:
        return None
    return x
```

### Literal

`Literal` permet de spécifier des valeurs exactes :

```python
from typing import Literal

def traiter_direction(
    direction: Literal["nord", "sud", "est", "ouest"]
) -> str:
    """Traite une direction."""
    return f"Aller vers {direction}"

# Utilisation
traiter_direction("nord")  # OK
# traiter_direction("haut")  # Erreur de type
```

## Exemples pratiques

### Exemple 1 : Fonction avec types complexes

```python
from typing import List, Dict, Tuple

def analyser_texte(
    texte: str,
    mots_cles: List[str]
) -> Dict[str, int]:
    """
    Analyse un texte et compte les occurrences des mots-clés.
    
    Args:
        texte: Texte à analyser
        mots_cles: Liste de mots-clés à chercher
        
    Returns:
        Dictionnaire avec les mots-clés et leur nombre d'occurrences
    """
    resultat: Dict[str, int] = {}
    mots = texte.lower().split()
    
    for mot_cle in mots_cles:
        resultat[mot_cle] = mots.count(mot_cle.lower())
    
    return resultat
```

### Exemple 2 : Classe typée

```python
from typing import List, Optional

class Utilisateur:
    def __init__(
        self,
        nom: str,
        age: int,
        emails: Optional[List[str]] = None
    ):
        self.nom: str = nom
        self.age: int = age
        self.emails: List[str] = emails if emails is not None else []
    
    def ajouter_email(self, email: str) -> None:
        """Ajoute un email."""
        if email not in self.emails:
            self.emails.append(email)
    
    def obtenir_emails(self) -> List[str]:
        """Retourne la liste des emails."""
        return self.emails.copy()
```

### Exemple 3 : Fonction avec callback

```python
from typing import Callable, List

def filtrer(
    elements: List[int],
    condition: Callable[[int], bool]
) -> List[int]:
    """Filtre une liste selon une condition."""
    return [e for e in elements if condition(e)]

# Utilisation
nombres = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]
pairs = filtrer(nombres, lambda x: x % 2 == 0)
print(pairs)  # [2, 4, 6, 8, 10]
```

## Bonnes pratiques

### 1. Annotez progressivement

Vous n'avez pas besoin d'annoter tout d'un coup :

```python
# Commencez par les fonctions publiques
def fonction_publique(parametre: int) -> str:
    return str(parametre)

# Puis les fonctions internes importantes
def _fonction_interne(donnees: List[int]) -> None:
    pass
```

### 2. Utilisez des alias pour les types complexes

```python
from typing import Dict, List, Any

# Alias pour simplifier
UserDict = Dict[str, Any]
UserList = List[UserDict]

def traiter_utilisateurs(utilisateurs: UserList) -> UserList:
    return utilisateurs
```

### 3. Documentez avec docstrings ET annotations

```python
def calculer_moyenne(nombres: List[float]) -> float:
    """
    Calcule la moyenne d'une liste de nombres.
    
    Args:
        nombres: Liste de nombres à moyenner
        
    Returns:
        La moyenne des nombres
        
    Raises:
        ValueError: Si la liste est vide
    """
    if not nombres:
        raise ValueError("La liste ne peut pas être vide")
    return sum(nombres) / len(nombres)
```

### 4. Évitez Any sauf si nécessaire

```python
# ❌ Trop permissif
def traiter(valeur: Any) -> Any:
    return valeur

# ✅ Plus précis
def traiter(valeur: int | str) -> str:
    return str(valeur)
```

## Points clés à retenir

- ✅ Le module `typing` fournit les outils pour le **typage statique optionnel**
- ✅ Python 3.9+ permet d'utiliser `list[int]` au lieu de `List[int]`
- ✅ `TypeVar` permet de créer des **types génériques**
- ✅ `Callable` permet de typer les **fonctions et callables**
- ✅ `Literal` permet de spécifier des **valeurs exactes**
- ✅ Les annotations sont **optionnelles** et **non vérifiées à l'exécution**
- ✅ Utilisez des **alias** pour simplifier les types complexes
- ✅ **Documentez** avec docstrings ET annotations

Le module `typing` est essentiel pour ajouter du typage statique à votre code Python. Il améliore la lisibilité, la maintenabilité et permet la détection d'erreurs avec des outils comme mypy.
