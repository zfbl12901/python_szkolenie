---
title: "NumPy"
order: 9.01.01
parent: "09-01-data-manipulation.md"
tags: ["python", "numpy", "numerique", "tableaux"]
---

# NumPy

NumPy est la bibliothèque fondamentale pour le calcul numérique en Python, fournissant des tableaux multidimensionnels performants. C'est la base de l'écosystème data science Python.

## Concepts de base

**NumPy** (Numerical Python) fournit :
- **ndarray** : Tableaux multidimensionnels homogènes et performants
- **Opérations vectorisées** : Calculs rapides sur des tableaux entiers
- **Broadcasting** : Opérations entre tableaux de tailles différentes
- **Fonctions mathématiques** : Bibliothèque complète de fonctions numériques

### Pourquoi NumPy ?

- **Performance** : 10-100x plus rapide que les listes Python
- **Mémoire** : Stockage compact et efficace
- **Fonctionnalités** : Opérations mathématiques avancées
- **Base** : Fondation pour Pandas, SciPy, scikit-learn

## Installation et import

### Installation

```bash
# Installer NumPy
pip install numpy

# Ou avec Poetry
poetry add numpy
```

### Import conventionnel

```python
import numpy as np

# Utilisation
arr = np.array([1, 2, 3])
```

## Tableaux NumPy (ndarray)

### Création de tableaux

```python
import numpy as np

# Depuis une liste
arr1 = np.array([1, 2, 3, 4, 5])
print(arr1)  # [1 2 3 4 5]

# Tableau 2D
arr2 = np.array([[1, 2, 3], [4, 5, 6]])
print(arr2)
# [[1 2 3]
#  [4 5 6]]

# Tableau 3D
arr3 = np.array([[[1, 2], [3, 4]], [[5, 6], [7, 8]]])
```

### Tableaux avec valeurs initiales

```python
# Zéros
zeros = np.zeros((3, 4))
# [[0. 0. 0. 0.]
#  [0. 0. 0. 0.]
#  [0. 0. 0. 0.]]

# Uns
ones = np.ones((2, 3))
# [[1. 1. 1.]
#  [1. 1. 1.]]

# Valeur constante
full = np.full((2, 2), 7)
# [[7 7]
#  [7 7]]

# Identité
identity = np.eye(3)
# [[1. 0. 0.]
#  [0. 1. 0.]
#  [0. 0. 1.]]
```

### Tableaux avec séquences

```python
# Range linéaire
arr = np.arange(0, 10, 2)  # [0 2 4 6 8]

# Linspace (nombre de points)
arr = np.linspace(0, 1, 5)  # [0.   0.25 0.5  0.75 1.  ]

# Random
random_arr = np.random.rand(3, 3)  # 3x3 valeurs aléatoires [0, 1)
random_int = np.random.randint(0, 10, (3, 3))  # Entiers aléatoires
```

### Propriétés des tableaux

```python
arr = np.array([[1, 2, 3], [4, 5, 6]])

print(arr.shape)      # (2, 3) - dimensions
print(arr.size)       # 6 - nombre total d'éléments
print(arr.ndim)       # 2 - nombre de dimensions
print(arr.dtype)      # int64 - type des données
print(arr.itemsize)   # 8 - taille en bytes d'un élément
```

### Types de données

```python
# Spécifier le type
arr_int = np.array([1, 2, 3], dtype=np.int32)
arr_float = np.array([1.0, 2.0, 3.0], dtype=np.float64)
arr_bool = np.array([True, False, True], dtype=bool)
arr_str = np.array(['a', 'b', 'c'], dtype='U10')  # Chaîne Unicode

# Conversion de type
arr = np.array([1, 2, 3])
arr_float = arr.astype(np.float64)
```

## Opérations vectorisées

### Opérations arithmétiques

```python
arr1 = np.array([1, 2, 3, 4])
arr2 = np.array([5, 6, 7, 8])

# Addition élément par élément
result = arr1 + arr2  # [ 6  8 10 12]

# Soustraction
result = arr2 - arr1  # [4 4 4 4]

# Multiplication
result = arr1 * arr2  # [ 5 12 21 32]

# Division
result = arr2 / arr1  # [5.  3.  2.33333333 2.  ]

# Puissance
result = arr1 ** 2  # [ 1  4  9 16]
```

### Opérations avec scalaires

```python
arr = np.array([1, 2, 3, 4])

# Addition
result = arr + 10  # [11 12 13 14]

# Multiplication
result = arr * 2  # [2 4 6 8]

# Division
result = arr / 2  # [0.5 1.  1.5 2. ]
```

### Fonctions mathématiques

```python
arr = np.array([1, 2, 3, 4])

# Fonctions élémentaires
np.sqrt(arr)      # Racine carrée
np.exp(arr)       # Exponentielle
np.log(arr)       # Logarithme naturel
np.sin(arr)       # Sinus
np.cos(arr)       # Cosinus
np.abs(arr)       # Valeur absolue
np.round(arr, 2)  # Arrondi
```

### Agrégations

```python
arr = np.array([[1, 2, 3], [4, 5, 6]])

# Somme
np.sum(arr)        # 21 - somme totale
np.sum(arr, axis=0)  # [5 7 9] - somme par colonne
np.sum(arr, axis=1)  # [6 15] - somme par ligne

# Moyenne
np.mean(arr)       # 3.5
np.mean(arr, axis=0)  # [2.5 3.5 4.5]

# Min/Max
np.min(arr)        # 1
np.max(arr)        # 6
np.argmin(arr)     # 0 - index du minimum
np.argmax(arr)     # 5 - index du maximum

# Autres
np.std(arr)        # Écart-type
np.var(arr)        # Variance
np.median(arr)     # Médiane
np.percentile(arr, 50)  # Percentile
```

## Broadcasting

### Principe du broadcasting

Le broadcasting permet d'effectuer des opérations entre tableaux de tailles différentes :

```python
# Tableau 2D
arr = np.array([[1, 2, 3], [4, 5, 6]])

# Broadcasting avec un scalaire
result = arr + 10
# [[11 12 13]
#  [14 15 16]]

# Broadcasting avec un vecteur 1D
result = arr + np.array([1, 2, 3])
# [[2 4 6]
#  [5 7 9]]

# Broadcasting avec un vecteur colonne
result = arr + np.array([[1], [2]])
# [[2 3 4]
#  [6 7 8]]
```

### Règles du broadcasting

1. Les dimensions sont comparées de droite à gauche
2. Compatible si les dimensions sont égales ou l'une est 1
3. Le tableau le plus petit est "étendu" pour correspondre

```python
# Exemple 1 : Compatible
arr1 = np.array([[1, 2, 3], [4, 5, 6]])  # Shape: (2, 3)
arr2 = np.array([1, 2, 3])                # Shape: (3,)
# Résultat: (2, 3) - arr2 est étendu

# Exemple 2 : Compatible
arr1 = np.array([[1], [2], [3]])          # Shape: (3, 1)
arr2 = np.array([1, 2, 3])                # Shape: (3,)
# Résultat: (3, 3)

# Exemple 3 : Incompatible
arr1 = np.array([[1, 2, 3], [4, 5, 6]])  # Shape: (2, 3)
arr2 = np.array([1, 2])                   # Shape: (2,)
# ❌ Erreur : dimensions incompatibles
```

## Indexation et slicing

### Indexation de base

```python
arr = np.array([1, 2, 3, 4, 5])

# Indexation simple
print(arr[0])    # 1
print(arr[-1])   # 5 (dernier élément)

# Slicing
print(arr[1:4])  # [2 3 4]
print(arr[:3])    # [1 2 3]
print(arr[2:])    # [3 4 5]
```

### Indexation 2D

```python
arr = np.array([[1, 2, 3], [4, 5, 6], [7, 8, 9]])

# Indexation
print(arr[0, 1])      # 2 - élément à la ligne 0, colonne 1
print(arr[0])         # [1 2 3] - première ligne
print(arr[:, 1])      # [2 5 8] - deuxième colonne

# Slicing
print(arr[0:2, 1:3])  # [[2 3]
                      #  [5 6]]
```

### Indexation booléenne

```python
arr = np.array([1, 2, 3, 4, 5])

# Filtrage avec condition
mask = arr > 3
print(mask)           # [False False False  True  True]
print(arr[mask])      # [4 5]

# Syntaxe courte
print(arr[arr > 3])   # [4 5]
print(arr[(arr > 2) & (arr < 5)])  # [3 4]
```

### Indexation avancée

```python
arr = np.array([1, 2, 3, 4, 5])

# Indexation avec liste
indices = [0, 2, 4]
print(arr[indices])   # [1 3 5]

# Indexation 2D avec listes
arr2d = np.array([[1, 2, 3], [4, 5, 6], [7, 8, 9]])
rows = [0, 2]
cols = [1, 2]
print(arr2d[rows, cols])  # [2 9]
```

## Manipulation de tableaux

### Redimensionnement

```python
arr = np.array([1, 2, 3, 4, 5, 6])

# Reshape
arr_2d = arr.reshape(2, 3)
# [[1 2 3]
#  [4 5 6]]

# Flatten
arr_flat = arr_2d.flatten()  # [1 2 3 4 5 6]

# Resize (modifie le tableau)
arr.resize(3, 2)
```

### Concatenation

```python
arr1 = np.array([1, 2, 3])
arr2 = np.array([4, 5, 6])

# Concatenation
result = np.concatenate([arr1, arr2])  # [1 2 3 4 5 6]

# Stack vertical
result = np.vstack([arr1, arr2])
# [[1 2 3]
#  [4 5 6]]

# Stack horizontal
result = np.hstack([arr1, arr2])  # [1 2 3 4 5 6]
```

### Division

```python
arr = np.array([1, 2, 3, 4, 5, 6])

# Split
parts = np.split(arr, 3)  # [array([1, 2]), array([3, 4]), array([5, 6])]

# Array split (tailles inégales)
parts = np.array_split(arr, 4)  # Divise en 4 parties approximativement égales
```

## Performance et optimisation

### Comparaison avec les listes Python

```python
import numpy as np
import time

# Liste Python
python_list = list(range(1000000))

# Tableau NumPy
numpy_array = np.array(range(1000000))

# Opération sur liste Python
start = time.time()
result = [x * 2 for x in python_list]
python_time = time.time() - start

# Opération vectorisée NumPy
start = time.time()
result = numpy_array * 2
numpy_time = time.time() - start

print(f"Python: {python_time:.4f}s")
print(f"NumPy: {numpy_time:.4f}s")
# NumPy est généralement 10-100x plus rapide
```

### Bonnes pratiques

```python
# ✅ Bon : Utiliser la vectorisation
arr = np.array([1, 2, 3, 4, 5])
result = arr * 2  # Vectorisé

# ❌ Éviter : Boucles Python
result = []
for x in arr:
    result.append(x * 2)
result = np.array(result)

# ✅ Bon : Utiliser les fonctions NumPy
result = np.sum(arr)

# ❌ Éviter : sum() Python
result = sum(arr)  # Plus lent
```

## Exemples pratiques

### Exemple 1 : Calculs statistiques

```python
import numpy as np

# Données de température
temperatures = np.array([20, 22, 21, 23, 25, 24, 22, 20, 19, 21])

# Statistiques
mean_temp = np.mean(temperatures)
std_temp = np.std(temperatures)
min_temp = np.min(temperatures)
max_temp = np.max(temperatures)

print(f"Moyenne: {mean_temp:.2f}°C")
print(f"Écart-type: {std_temp:.2f}°C")
print(f"Min: {min_temp}°C, Max: {max_temp}°C")

# Jours avec température > moyenne
hot_days = temperatures[temperatures > mean_temp]
print(f"Jours chauds: {hot_days}")
```

### Exemple 2 : Manipulation d'images

```python
import numpy as np

# Image simulée (hauteur, largeur, canaux RGB)
image = np.random.randint(0, 256, (100, 100, 3), dtype=np.uint8)

# Conversion en niveaux de gris
gray = np.mean(image, axis=2).astype(np.uint8)

# Normalisation
normalized = image.astype(np.float32) / 255.0

# Filtre simple (moyenne)
kernel = np.ones((3, 3)) / 9
# (Application du filtre nécessiterait scipy ou convolution manuelle)
```

### Exemple 3 : Calculs matriciels

```python
import numpy as np

# Matrices
A = np.array([[1, 2], [3, 4]])
B = np.array([[5, 6], [7, 8]])

# Multiplication matricielle
C = np.dot(A, B)
# ou
C = A @ B  # Opérateur @ (Python 3.5+)

# Transposition
A_T = A.T

# Inverse
A_inv = np.linalg.inv(A)

# Déterminant
det = np.linalg.det(A)

# Valeurs propres
eigenvalues, eigenvectors = np.linalg.eig(A)
```

## Points clés à retenir

- ✅ NumPy fournit des **tableaux multidimensionnels performants** (ndarray)
- ✅ **Opérations vectorisées** : 10-100x plus rapide que les boucles Python
- ✅ **Broadcasting** : Opérations entre tableaux de tailles différentes
- ✅ **Fonctions mathématiques** : Bibliothèque complète intégrée
- ✅ **Base de l'écosystème** : Fondation pour Pandas, SciPy, scikit-learn
- ✅ **Performance** : Optimisé en C/Fortran
- ✅ Parfait pour les **calculs numériques** et la manipulation de données

NumPy est la base incontournable de la data science Python. Maîtriser NumPy est essentiel avant d'utiliser Pandas ou d'autres bibliothèques de data science.
