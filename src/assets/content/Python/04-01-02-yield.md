---
title: "yield"
order: 4.01.02
parent: "04-01-iterateurs-et-generateurs.md"
tags: ["python", "yield", "generateur"]
---

# yield

Le mot-clé `yield` transforme une fonction en générateur, permettant de produire des valeurs une à une plutôt que toutes en même temps. C'est l'un des concepts les plus puissants et élégants de Python.

## Concepts de base

Quand une fonction contient `yield`, elle devient une **fonction génératrice**. Au lieu de retourner une valeur et terminer, elle produit une valeur, suspend son exécution, et reprend là où elle s'est arrêtée au prochain appel.

```python
def generateur_simple():
    yield 1
    yield 2
    yield 3

# Utilisation
gen = generateur_simple()
print(next(gen))  # 1
print(next(gen))  # 2
print(next(gen))  # 3
# print(next(gen))  # StopIteration

# Ou avec une boucle
for valeur in generateur_simple():
    print(valeur)  # 1, 2, 3
```

## Fonctions génératrices

### Caractéristiques

Une fonction génératrice :
- Contient au moins un `yield`
- Retourne un objet générateur (pas une valeur directement)
- Maintient son état entre les appels
- Reprend l'exécution après le `yield` au prochain appel

```python
def compteur(max_val):
    """Fonction génératrice qui compte jusqu'à max_val."""
    current = 0
    while current < max_val:
        yield current
        current += 1

# Création du générateur
gen = compteur(5)
print(type(gen))  # <class 'generator'>

# Utilisation
for nombre in gen:
    print(nombre)  # 0, 1, 2, 3, 4
```

### État préservé

Contrairement aux fonctions normales, les générateurs préservent leur état :

```python
def generateur_avec_etat():
    print("Début")
    yield 1
    print("Milieu")
    yield 2
    print("Fin")
    yield 3

gen = generateur_avec_etat()
print("Premier appel")
print(next(gen))  # Début, puis 1
print("Deuxième appel")
print(next(gen))  # Milieu, puis 2
print("Troisième appel")
print(next(gen))  # Fin, puis 3
```

## yield vs return

### Différences fondamentales

| `return` | `yield` |
|----------|---------|
| Termine la fonction | Suspend la fonction |
| Retourne une valeur | Produit une valeur |
| Perd l'état | Préserve l'état |
| Ne peut être appelé qu'une fois | Peut être appelé plusieurs fois |

```python
# Fonction normale avec return
def fonction_normale():
    return 1
    # Code après return jamais exécuté
    return 2  # ❌ Jamais atteint

# Fonction génératrice avec yield
def fonction_generatrice():
    yield 1
    # Code après yield est exécuté au prochain appel
    yield 2  # ✅ Atteint au deuxième appel
    yield 3  # ✅ Atteint au troisième appel

gen = fonction_generatrice()
print(next(gen))  # 1
print(next(gen))  # 2
print(next(gen))  # 3
```

### Exemple comparatif

```python
# ❌ Fonction normale : crée toute la liste en mémoire
def carres_liste(n):
    resultat = []
    for i in range(n):
        resultat.append(i ** 2)
    return resultat

# Utilisation
liste = carres_liste(1000000)  # Crée une liste de 1 million d'éléments en mémoire

# ✅ Fonction génératrice : produit les valeurs à la demande
def carres_generateur(n):
    for i in range(n):
        yield i ** 2

# Utilisation
gen = carres_generateur(1000000)  # Ne crée rien en mémoire
for carre in gen:
    if carre > 100:  # Peut s'arrêter tôt
        break
    print(carre)
```

## yield from

### Délégation à un autre générateur

`yield from` permet de déléguer à un autre générateur ou itérable :

```python
def generateur1():
    yield 1
    yield 2

def generateur2():
    yield 3
    yield 4

def generateur_combine():
    yield from generateur1()  # Délègue à generateur1
    yield from generateur2()  # Délègue à generateur2

for valeur in generateur_combine():
    print(valeur)  # 1, 2, 3, 4
```

### Équivalent sans yield from

```python
# Sans yield from (plus verbeux)
def generateur_combine_manuel():
    for valeur in generateur1():
        yield valeur
    for valeur in generateur2():
        yield valeur

# Avec yield from (plus élégant)
def generateur_combine():
    yield from generateur1()
    yield from generateur2()
```

### Exemple pratique : Aplatir une liste

```python
def aplatir(liste):
    """Aplatit une liste imbriquée."""
    for element in liste:
        if isinstance(element, list):
            yield from aplatir(element)  # Récursion avec yield from
        else:
            yield element

liste_imbriquee = [1, [2, 3], [4, [5, 6]], 7]
for valeur in aplatir(liste_imbriquee):
    print(valeur)  # 1, 2, 3, 4, 5, 6, 7
```

## Exemples pratiques

### Exemple 1 : Générateur de nombres pairs

```python
def nombres_pairs(max_val):
    """Génère les nombres pairs jusqu'à max_val."""
    for i in range(0, max_val, 2):
        yield i

for pair in nombres_pairs(10):
    print(pair)  # 0, 2, 4, 6, 8
```

### Exemple 2 : Lire un fichier ligne par ligne

```python
def lire_fichier(nom_fichier):
    """Lit un fichier ligne par ligne (générateur)."""
    with open(nom_fichier, 'r') as f:
        for ligne in f:
            yield ligne.rstrip('\n')

# Utilisation (efficace en mémoire)
for ligne in lire_fichier("fichier.txt"):
    print(ligne)
```

### Exemple 3 : Suite de Fibonacci

```python
def fibonacci(max_val=None):
    """Génère la suite de Fibonacci."""
    a, b = 0, 1
    while max_val is None or b < max_val:
        yield b
        a, b = b, a + b

for nombre in fibonacci(100):
    print(nombre)  # 1, 1, 2, 3, 5, 8, 13, 21, 34, 55, 89
```

### Exemple 4 : Générateur avec état complexe

```python
def generateur_avec_etat():
    """Générateur qui maintient un état complexe."""
    etat = {"compteur": 0, "total": 0}
    
    while etat["compteur"] < 10:
        etat["compteur"] += 1
        etat["total"] += etat["compteur"]
        yield {
            "valeur": etat["compteur"],
            "total": etat["total"]
        }

for etat in generateur_avec_etat():
    print(etat)
    # {'valeur': 1, 'total': 1}
    # {'valeur': 2, 'total': 3}
    # {'valeur': 3, 'total': 6}
    # ...
```

### Exemple 5 : Pipeline de traitement

```python
def nombres():
    """Génère les nombres."""
    i = 0
    while True:
        yield i
        i += 1

def filtrer_pairs(gen):
    """Filtre les nombres pairs."""
    for n in gen:
        if n % 2 == 0:
            yield n

def multiplier(gen, facteur):
    """Multiplie par un facteur."""
    for n in gen:
        yield n * facteur

# Pipeline : nombres → filtrer pairs → multiplier
pipeline = multiplier(filtrer_pairs(nombres()), 3)

for i, valeur in enumerate(pipeline):
    if i >= 5:
        break
    print(valeur)  # 0, 6, 12, 18, 24
```

## Envoyer des valeurs au générateur

### send()

Les générateurs peuvent recevoir des valeurs via `send()` :

```python
def generateur_interactif():
    """Générateur qui peut recevoir des valeurs."""
    valeur = yield "Premier"
    while True:
        valeur = yield f"Reçu: {valeur}"

gen = generateur_interactif()
print(next(gen))  # "Premier" (doit appeler next() d'abord)
print(gen.send("Hello"))  # "Reçu: Hello"
print(gen.send("World"))   # "Reçu: World"
```

### Exemple pratique : Coroutine simple

```python
def accumulateur():
    """Générateur qui accumule des valeurs."""
    total = 0
    while True:
        valeur = yield total
        if valeur is not None:
            total += valeur

acc = accumulateur()
next(acc)  # Initialisation
print(acc.send(10))  # 10
print(acc.send(5))   # 15
print(acc.send(3))   # 18
```

## Pièges courants

### Piège 1 : Confondre générateur et liste

```python
def carres(n):
    for i in range(n):
        yield i ** 2

gen = carres(5)
print(list(gen))  # [0, 1, 4, 9, 16]
print(list(gen))  # [] ⚠️ Générateur épuisé!

# ✅ Solution : recréer le générateur
gen = carres(5)
print(list(gen))  # [0, 1, 4, 9, 16]
```

### Piège 2 : Oublier d'initialiser avec next()

```python
def generateur():
    valeur = yield "Début"
    yield f"Reçu: {valeur}"

gen = generateur()
# gen.send("test")  # ❌ TypeError: can't send non-None value to a just-started generator

# ✅ Solution : initialiser avec next()
gen = generateur()
next(gen)  # "Début"
gen.send("test")  # "Reçu: test"
```

### Piège 3 : Modifier une variable externe

```python
# ⚠️ Attention aux variables externes
liste = []

def generateur():
    for i in range(5):
        liste.append(i)  # ⚠️ Effet de bord
        yield i

gen = generateur()
list(gen)
print(liste)  # [0, 1, 2, 3, 4] ⚠️ Liste modifiée
```

## Bonnes pratiques

### 1. Utilisez des générateurs pour les grandes séquences

```python
# ✅ Générateur (efficace)
def lire_lignes(nom_fichier):
    with open(nom_fichier) as f:
        for ligne in f:
            yield ligne

# ❌ Liste (consomme toute la mémoire)
def lire_lignes_liste(nom_fichier):
    with open(nom_fichier) as f:
        return f.readlines()
```

### 2. Documentez le comportement

```python
def generateur(n):
    """
    Génère les carrés des nombres de 0 à n-1.
    
    Args:
        n: Nombre de valeurs à générer
        
    Yields:
        Les carrés des nombres (0, 1, 4, 9, ...)
    """
    for i in range(n):
        yield i ** 2
```

### 3. Utilisez yield from pour la délégation

```python
# ✅ Élégant avec yield from
def combine(*generateurs):
    for gen in generateurs:
        yield from gen

# ❌ Plus verbeux sans yield from
def combine_manuel(*generateurs):
    for gen in generateurs:
        for valeur in gen:
            yield valeur
```

## Points clés à retenir

- ✅ `yield` transforme une fonction en **générateur**
- ✅ Les générateurs **préservent leur état** entre les appels
- ✅ `yield` **suspend** l'exécution, `return` la **termine**
- ✅ `yield from` permet de **déléguer** à un autre générateur
- ✅ Les générateurs sont **efficaces en mémoire** (lazy evaluation)
- ✅ Un générateur **épuisé** ne peut plus être utilisé
- ✅ Utilisez `next()` pour **initialiser** avant `send()`
- ✅ Les générateurs sont **itérables** et peuvent être utilisés dans les boucles

Le mot-clé `yield` est l'un des plus puissants de Python. Il permet de créer des générateurs élégants et efficaces, essentiels pour travailler avec de grandes séquences de données.
