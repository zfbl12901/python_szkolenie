---
title: "CI/CD avec GitHub Actions et GitLab CI"
order: 2
parent: "40-devops-python.md"
tags: ["python", "devops", "ci-cd", "github-actions", "gitlab"]
---

# CI/CD avec GitHub Actions et GitLab CI

## Introduction

L'intégration continue (CI) et le déploiement continu (CD) sont des pratiques DevOps essentielles qui automatisent le processus de livraison logicielle, de la validation du code jusqu'au déploiement en production.

### CI/CD : Définitions

**Continuous Integration (CI)**
- Intégration fréquente du code dans la branche principale
- Tests automatisés à chaque commit
- Détection rapide des problèmes

**Continuous Delivery (CD)**
- Code toujours prêt à être déployé
- Déploiement automatisé vers les environnements de test
- Déploiement en production manuel

**Continuous Deployment (CD)**
- Déploiement automatique en production
- Chaque commit validé est déployé
- Nécessite une confiance totale dans les tests

### Pipeline CI/CD type

```
┌──────────┐   ┌──────────┐   ┌──────────┐   ┌──────────┐   ┌──────────┐
│   Push   │ → │  Build   │ → │   Test   │ → │ Deploy   │ → │ Monitor  │
│   Code   │   │          │   │          │   │  Staging │   │          │
└──────────┘   └──────────┘   └──────────┘   └──────────┘   └──────────┘
                                                    │
                                                    ▼
                                              ┌──────────┐
                                              │ Deploy   │
                                              │   Prod   │
                                              └──────────┘
```

## GitHub Actions

### Introduction à GitHub Actions

GitHub Actions est un système CI/CD intégré à GitHub qui permet d'automatiser les workflows directement dans vos dépôts.

### Concepts de base

| Concept | Description |
|---------|-------------|
| **Workflow** | Processus automatisé (fichier YAML) |
| **Job** | Ensemble de steps exécutés sur un runner |
| **Step** | Tâche individuelle (commande ou action) |
| **Action** | Application réutilisable |
| **Runner** | Serveur qui exécute les workflows |
| **Event** | Déclencheur du workflow (push, PR, etc.) |

### Premier workflow GitHub Actions

```yaml
# .github/workflows/ci.yml
name: CI Pipeline

# Déclencheurs
on:
  push:
    branches: [ main, develop ]
  pull_request:
    branches: [ main ]

# Jobs
jobs:
  test:
    runs-on: ubuntu-latest
    
    steps:
      # 1. Checkout du code
      - name: Checkout code
        uses: actions/checkout@v3
      
      # 2. Setup Python
      - name: Set up Python
        uses: actions/setup-python@v4
        with:
          python-version: '3.11'
      
      # 3. Cache des dépendances
      - name: Cache pip packages
        uses: actions/cache@v3
        with:
          path: ~/.cache/pip
          key: ${{ runner.os }}-pip-${{ hashFiles('**/requirements.txt') }}
          restore-keys: |
            ${{ runner.os }}-pip-
      
      # 4. Installation des dépendances
      - name: Install dependencies
        run: |
          python -m pip install --upgrade pip
          pip install -r requirements.txt
          pip install -r requirements-dev.txt
      
      # 5. Linting
      - name: Lint with flake8
        run: |
          flake8 src/ --count --select=E9,F63,F7,F82 --show-source --statistics
          flake8 src/ --count --exit-zero --max-complexity=10 --max-line-length=127 --statistics
      
      # 6. Tests
      - name: Run tests
        run: |
          pytest tests/ -v --cov=src --cov-report=xml --cov-report=html
      
      # 7. Upload coverage
      - name: Upload coverage to Codecov
        uses: codecov/codecov-action@v3
        with:
          file: ./coverage.xml
          fail_ci_if_error: true
```

### Workflow CI complet pour Python

```yaml
# .github/workflows/python-ci.yml
name: Python CI

on:
  push:
    branches: [ main, develop ]
  pull_request:
    branches: [ main ]

jobs:
  # Job 1: Tests sur plusieurs versions Python
  test:
    runs-on: ${{ matrix.os }}
    strategy:
      matrix:
        os: [ubuntu-latest, windows-latest, macos-latest]
        python-version: ['3.9', '3.10', '3.11']
    
    steps:
      - uses: actions/checkout@v3
      
      - name: Set up Python ${{ matrix.python-version }}
        uses: actions/setup-python@v4
        with:
          python-version: ${{ matrix.python-version }}
      
      - name: Install dependencies
        run: |
          python -m pip install --upgrade pip
          pip install -r requirements.txt
          pip install -r requirements-dev.txt
      
      - name: Run tests
        run: pytest tests/ -v --cov=src
      
      - name: Generate coverage report
        if: matrix.os == 'ubuntu-latest' && matrix.python-version == '3.11'
        run: |
          pip install coverage
          coverage xml
      
      - name: Upload coverage
        if: matrix.os == 'ubuntu-latest' && matrix.python-version == '3.11'
        uses: codecov/codecov-action@v3
  
  # Job 2: Quality checks
  quality:
    runs-on: ubuntu-latest
    
    steps:
      - uses: actions/checkout@v3
      
      - name: Set up Python
        uses: actions/setup-python@v4
        with:
          python-version: '3.11'
      
      - name: Install tools
        run: |
          pip install black flake8 mypy pylint isort bandit safety
      
      - name: Check code formatting (black)
        run: black --check src/
      
      - name: Check import sorting (isort)
        run: isort --check-only src/
      
      - name: Lint with flake8
        run: flake8 src/
      
      - name: Type checking (mypy)
        run: mypy src/
      
      - name: Security check (bandit)
        run: bandit -r src/
      
      - name: Check dependencies (safety)
        run: safety check
  
  # Job 3: Build Docker image
  build:
    runs-on: ubuntu-latest
    needs: [test, quality]
    
    steps:
      - uses: actions/checkout@v3
      
      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v2
      
      - name: Login to Docker Hub
        uses: docker/login-action@v2
        with:
          username: ${{ secrets.DOCKER_USERNAME }}
          password: ${{ secrets.DOCKER_PASSWORD }}
      
      - name: Build and push
        uses: docker/build-push-action@v4
        with:
          context: .
          push: true
          tags: |
            myapp:latest
            myapp:${{ github.sha }}
          cache-from: type=registry,ref=myapp:buildcache
          cache-to: type=registry,ref=myapp:buildcache,mode=max
```

### Workflow CD (Déploiement)

```yaml
# .github/workflows/deploy.yml
name: Deploy to Production

on:
  push:
    branches: [ main ]
    tags:
      - 'v*'

jobs:
  deploy:
    runs-on: ubuntu-latest
    environment:
      name: production
      url: https://myapp.com
    
    steps:
      - uses: actions/checkout@v3
      
      - name: Set up Python
        uses: actions/setup-python@v4
        with:
          python-version: '3.11'
      
      - name: Install dependencies
        run: |
          pip install -r requirements.txt
          pip install fabric
      
      - name: Run tests
        run: pytest tests/ -v
      
      - name: Build Docker image
        run: docker build -t myapp:${{ github.sha }} .
      
      - name: Push to registry
        run: |
          echo ${{ secrets.DOCKER_PASSWORD }} | docker login -u ${{ secrets.DOCKER_USERNAME }} --password-stdin
          docker push myapp:${{ github.sha }}
      
      - name: Deploy to server
        env:
          SSH_PRIVATE_KEY: ${{ secrets.SSH_PRIVATE_KEY }}
          SERVER_HOST: ${{ secrets.SERVER_HOST }}
          SERVER_USER: ${{ secrets.SERVER_USER }}
        run: |
          mkdir -p ~/.ssh
          echo "$SSH_PRIVATE_KEY" > ~/.ssh/id_rsa
          chmod 600 ~/.ssh/id_rsa
          ssh-keyscan -H $SERVER_HOST >> ~/.ssh/known_hosts
          
          ssh $SERVER_USER@$SERVER_HOST << 'EOF'
            cd /app
            docker pull myapp:${{ github.sha }}
            docker-compose down
            docker-compose up -d
            docker image prune -f
          EOF
      
      - name: Health check
        run: |
          sleep 10
          curl -f https://myapp.com/health || exit 1
      
      - name: Notify deployment
        if: success()
        uses: 8398a7/action-slack@v3
        with:
          status: ${{ job.status }}
          text: 'Deployment successful! :rocket:'
          webhook_url: ${{ secrets.SLACK_WEBHOOK }}
```

### Actions réutilisables

```yaml
# .github/workflows/reusable-test.yml
name: Reusable Test Workflow

on:
  workflow_call:
    inputs:
      python-version:
        required: true
        type: string
    secrets:
      codecov-token:
        required: false

jobs:
  test:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v3
      
      - name: Set up Python
        uses: actions/setup-python@v4
        with:
          python-version: ${{ inputs.python-version }}
      
      - name: Run tests
        run: |
          pip install -r requirements.txt
          pytest tests/ -v --cov=src
```

```yaml
# .github/workflows/main.yml
name: Main CI

on: [push, pull_request]

jobs:
  test-39:
    uses: ./.github/workflows/reusable-test.yml
    with:
      python-version: '3.9'
  
  test-311:
    uses: ./.github/workflows/reusable-test.yml
    with:
      python-version: '3.11'
```

## GitLab CI/CD

### Introduction à GitLab CI

GitLab CI/CD est intégré directement dans GitLab et utilise des fichiers `.gitlab-ci.yml`.

### Pipeline GitLab basique

```yaml
# .gitlab-ci.yml
image: python:3.11

# Définir les stages
stages:
  - test
  - build
  - deploy

# Variables globales
variables:
  PIP_CACHE_DIR: "$CI_PROJECT_DIR/.cache/pip"

# Cache
cache:
  paths:
    - .cache/pip
    - venv/

# Avant chaque job
before_script:
  - python --version
  - pip install virtualenv
  - virtualenv venv
  - source venv/bin/activate
  - pip install -r requirements.txt

# Job: Tests unitaires
test:unit:
  stage: test
  script:
    - pip install pytest pytest-cov
    - pytest tests/unit/ -v --cov=src
  coverage: '/TOTAL.*\s+(\d+%)$/'
  artifacts:
    reports:
      coverage_report:
        coverage_format: cobertura
        path: coverage.xml

# Job: Tests d'intégration
test:integration:
  stage: test
  services:
    - postgres:15
    - redis:7
  variables:
    POSTGRES_DB: test_db
    POSTGRES_USER: test_user
    POSTGRES_PASSWORD: test_pass
    DATABASE_URL: "postgresql://test_user:test_pass@postgres:5432/test_db"
    REDIS_URL: "redis://redis:6379"
  script:
    - pytest tests/integration/ -v

# Job: Linting
lint:
  stage: test
  script:
    - pip install flake8 black mypy pylint
    - flake8 src/
    - black --check src/
    - mypy src/
    - pylint src/

# Job: Security check
security:
  stage: test
  script:
    - pip install bandit safety
    - bandit -r src/
    - safety check

# Job: Build Docker
build:docker:
  stage: build
  image: docker:latest
  services:
    - docker:dind
  script:
    - docker login -u $CI_REGISTRY_USER -p $CI_REGISTRY_PASSWORD $CI_REGISTRY
    - docker build -t $CI_REGISTRY_IMAGE:$CI_COMMIT_SHA .
    - docker push $CI_REGISTRY_IMAGE:$CI_COMMIT_SHA
  only:
    - main
    - develop

# Job: Deploy staging
deploy:staging:
  stage: deploy
  environment:
    name: staging
    url: https://staging.myapp.com
  script:
    - echo "Deploying to staging..."
    - ssh $STAGING_USER@$STAGING_HOST "cd /app && docker-compose pull && docker-compose up -d"
  only:
    - develop

# Job: Deploy production
deploy:production:
  stage: deploy
  environment:
    name: production
    url: https://myapp.com
  script:
    - echo "Deploying to production..."
    - ssh $PROD_USER@$PROD_HOST "cd /app && docker-compose pull && docker-compose up -d"
  when: manual
  only:
    - main
```

### Pipeline complexe avec templates

```yaml
# .gitlab-ci.yml
include:
  - template: Security/SAST.gitlab-ci.yml
  - template: Security/Dependency-Scanning.gitlab-ci.yml
  - template: Security/Secret-Detection.gitlab-ci.yml

image: python:3.11-slim

stages:
  - lint
  - test
  - build
  - deploy
  - monitor

variables:
  DOCKER_DRIVER: overlay2
  DOCKER_TLS_CERTDIR: "/certs"

# Template pour les jobs de test
.test-template: &test-template
  stage: test
  before_script:
    - pip install -r requirements.txt -r requirements-dev.txt
  artifacts:
    reports:
      junit: junit.xml
      coverage: coverage.xml
    paths:
      - htmlcov/
    expire_in: 1 week

# Tests unitaires
test:unit:
  <<: *test-template
  script:
    - pytest tests/unit/ -v --junitxml=junit.xml --cov=src --cov-report=xml --cov-report=html
  coverage: '/TOTAL.*\s+(\d+%)$/'

# Tests avec plusieurs versions Python
test:multi-python:
  <<: *test-template
  parallel:
    matrix:
      - PYTHON_VERSION: ["3.9", "3.10", "3.11"]
  image: python:${PYTHON_VERSION}-slim
  script:
    - pytest tests/ -v

# Linting avec plusieurs outils
lint:all:
  stage: lint
  script:
    - pip install black flake8 isort mypy pylint
    - echo "Running black..."
    - black --check src/
    - echo "Running isort..."
    - isort --check-only src/
    - echo "Running flake8..."
    - flake8 src/
    - echo "Running mypy..."
    - mypy src/ --ignore-missing-imports
    - echo "Running pylint..."
    - pylint src/ --exit-zero

# Build et push Docker
build:image:
  stage: build
  image: docker:latest
  services:
    - docker:dind
  before_script:
    - docker login -u $CI_REGISTRY_USER -p $CI_REGISTRY_PASSWORD $CI_REGISTRY
  script:
    - |
      if [ "$CI_COMMIT_REF_NAME" == "main" ]; then
        TAG="latest"
      else
        TAG="$CI_COMMIT_REF_NAME"
      fi
    - docker build -t $CI_REGISTRY_IMAGE:$TAG -t $CI_REGISTRY_IMAGE:$CI_COMMIT_SHA .
    - docker push $CI_REGISTRY_IMAGE:$TAG
    - docker push $CI_REGISTRY_IMAGE:$CI_COMMIT_SHA
  only:
    - main
    - develop
    - tags

# Deploy avec Kubernetes
deploy:k8s:
  stage: deploy
  image: bitnami/kubectl:latest
  environment:
    name: production
    url: https://myapp.com
    kubernetes:
      namespace: production
  script:
    - kubectl config use-context $KUBE_CONTEXT
    - kubectl set image deployment/myapp myapp=$CI_REGISTRY_IMAGE:$CI_COMMIT_SHA -n production
    - kubectl rollout status deployment/myapp -n production
  only:
    - main
  when: manual

# Health check post-déploiement
monitor:health:
  stage: monitor
  image: curlimages/curl:latest
  script:
    - |
      for i in {1..10}; do
        if curl -f https://myapp.com/health; then
          echo "Health check passed!"
          exit 0
        fi
        echo "Attempt $i failed, retrying..."
        sleep 5
      done
      echo "Health check failed!"
      exit 1
  only:
    - main
  needs:
    - deploy:k8s
```

### Multi-projet pipeline

```yaml
# .gitlab-ci.yml (projet principal)
trigger:backend:
  stage: trigger
  trigger:
    project: mygroup/backend
    branch: main
    strategy: depend

trigger:frontend:
  stage: trigger
  trigger:
    project: mygroup/frontend
    branch: main
```

## Comparaison GitHub Actions vs GitLab CI

| Aspect | GitHub Actions | GitLab CI |
|--------|----------------|-----------|
| **Configuration** | `.github/workflows/*.yml` | `.gitlab-ci.yml` |
| **Runners** | GitHub-hosted ou self-hosted | GitLab-hosted ou self-hosted |
| **Marketplace** | Large marketplace d'actions | Templates intégrés |
| **Prix** | 2000 min/mois gratuit | 400 min/mois gratuit |
| **Secrets** | Gestion native | Gestion native + Vault |
| **Artifacts** | Jusqu'à 500MB | Jusqu'à 1GB |
| **Matrix builds** | Oui | Oui (parallel) |
| **Environnements** | Protection rules | Environments |

## Tests dans le pipeline

### Configuration pytest pour CI

```python
# pytest.ini
[pytest]
minversion = 6.0
addopts = -ra -q --strict-markers --cov=src --cov-report=term-missing --cov-report=html --cov-report=xml
testpaths = tests
python_files = test_*.py
python_classes = Test*
python_functions = test_*
markers =
    slow: marks tests as slow
    integration: marks tests as integration tests
    unit: marks tests as unit tests
```

```python
# tests/conftest.py
import pytest

@pytest.fixture(scope="session")
def app():
    """Create application for testing"""
    from myapp import create_app
    app = create_app('testing')
    return app

@pytest.fixture(scope="session")
def client(app):
    """Create test client"""
    return app.test_client()

@pytest.fixture(scope="function")
def db(app):
    """Create database for testing"""
    from myapp.extensions import db as _db
    with app.app_context():
        _db.create_all()
        yield _db
        _db.drop_all()
```

### Tests avec coverage

```bash
# requirements-dev.txt
pytest>=7.4.0
pytest-cov>=4.1.0
pytest-mock>=3.11.1
pytest-asyncio>=0.21.1
pytest-xdist>=3.3.1  # Tests parallèles
```

```yaml
# GitHub Actions
- name: Run tests with coverage
  run: |
    pytest tests/ -v \
      --cov=src \
      --cov-report=term-missing \
      --cov-report=html \
      --cov-report=xml \
      --cov-fail-under=80
```

## Gestion des secrets

### GitHub Actions Secrets

```yaml
# Utilisation des secrets
- name: Deploy
  env:
    API_KEY: ${{ secrets.API_KEY }}
    DATABASE_URL: ${{ secrets.DATABASE_URL }}
  run: python deploy.py
```

### GitLab CI Variables

```yaml
# Variables protégées (via Settings > CI/CD > Variables)
deploy:
  script:
    - echo $DATABASE_URL
    - python deploy.py
  variables:
    ENV: production
```

### Chiffrement avec SOPS

```bash
# Installer SOPS
brew install sops

# Chiffrer un fichier
sops -e secrets.env > secrets.enc.env

# Déchiffrer dans le pipeline
sops -d secrets.enc.env > secrets.env
source secrets.env
```

## Notifications et intégrations

### Slack notifications

```yaml
# GitHub Actions
- name: Slack Notification
  uses: 8398a7/action-slack@v3
  with:
    status: ${{ job.status }}
    text: 'Pipeline completed'
    webhook_url: ${{ secrets.SLACK_WEBHOOK }}
  if: always()
```

```yaml
# GitLab CI
notify:slack:
  stage: .post
  script:
    - |
      curl -X POST -H 'Content-type: application/json' \
        --data '{"text":"Pipeline finished: '"$CI_PIPELINE_STATUS"'"}' \
        $SLACK_WEBHOOK_URL
  when: always
```

### Email notifications

```yaml
# GitLab CI (.gitlab-ci.yml)
# Configure dans Settings > Integrations > Emails on push
```

## Bonnes pratiques CI/CD

### ✅ À faire

1. **Tests rapides d'abord** : Fail fast
2. **Cache intelligent** : Dépendances, build artifacts
3. **Matrix builds** : Tester plusieurs versions
4. **Artifacts** : Sauvegarder les rapports
5. **Environnements** : Staging avant production
6. **Rollback automatique** : En cas d'échec
7. **Notifications** : Alerter en cas d'échec
8. **Security scanning** : Vulnérabilités, secrets
9. **Code quality gates** : Coverage minimum
10. **Documentation** : Pipeline bien documenté

### ❌ À éviter

1. **Secrets dans le code** : Toujours utiliser des variables
2. **Tests longs** : Optimiser ou paralléliser
3. **Déploiements non testés** : Toujours tester avant
4. **Ignorer les warnings** : Traiter les warnings
5. **Pipeline complexe** : Garder simple et lisible
6. **Pas de rollback** : Toujours avoir un plan B
7. **Notifications spam** : Notifier intelligemment
8. **Cache perpétuel** : Invalider le cache régulièrement

## Exercices pratiques

### Exercice 1 : Pipeline CI basique

Créer un pipeline qui :
- Installe les dépendances
- Lance les tests avec pytest
- Vérifie le coverage (>80%)
- Lint le code avec flake8

### Exercice 2 : Pipeline multi-environnement

Créer un pipeline qui :
- Deploy sur staging automatiquement
- Deploy sur production manuellement
- Rollback en cas d'échec de healthcheck

### Exercice 3 : Pipeline complet

Créer un pipeline qui :
- Tests sur Python 3.9, 3.10, 3.11
- Build Docker multi-arch (amd64, arm64)
- Security scanning
- Deploy sur Kubernetes
- Notifications Slack

## Ressources

- **GitHub Actions** : https://docs.github.com/en/actions
- **GitLab CI/CD** : https://docs.gitlab.com/ee/ci/
- **Awesome CI** : https://github.com/ligurio/awesome-ci
- **Pipeline Templates** : https://github.com/github/super-linter
